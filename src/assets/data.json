{
  "collections": [
    {
      "name": "Angular 大師之路",
      "items": [
        {
          "id": 1,
          "title": "一個簡易實踐 two way binding 的方法",
          "content": "在 Angular 中，通常我們會使用 `[(ngModel)]` 來實現 two way binding，這樣做基本上沒有什麼問題，但 `ngModel` 只能 binding 在常見的表單控制項上，如 `input`、`select` 等，難以自行在元件上時作出 two way binding，雖然還是可以做到，但相對麻煩了一點，今天就先來講一個簡單的實現 two way binding 的技巧吧！\n\n**類型**：技巧\n\n**難度**：3 顆星\n\n**實用度**：5 顆星\n\n想像一下有如下程式碼：\n\n```typescript\n@Component({\n  selector: 'app-info',\n  template: `\n    Name <input type=\"text\" [(ngModel)]=\"name\">\n  `\n})\nexport class InfoComponent {\n  @Input() name;\n}\n\n@Component({\n  selector: 'app-root',\n  template: `\n    <app-info [name]=\"name\"></app-info>\n    Result: {{ name }}\n  `\n})\nexport class AppComponent  {\n  name = 'Mike'\n}\n```\n\n在這段程式的 `InfoComponent` 之中，我們產生了一個輸入框，並使用 `@Input` 從外部決定資料，執行結果如下：\n\n![https://imgur.com/download/XXtW0vq](https://imgur.com/download/XXtW0vq)\n\n可以發現當 `InfoComponent` 內的資料變動時，外部的變數並不會跟著異動，這很正常，因為在 `@Input()` 收到資料後，就已經是另外一個記憶體位置了，因此變動時不會同步變動原來的變數內容，這時候我們可以簡單的加個 `@Output` 來解決，完成類似 two way binding 的效果：\n\n```typescript\n@Component({\n  selector: 'app-info',\n  template: `\n    Name <input type=\"text\" [(ngModel)]=\"name\" (input)=\"nameChange.emit(name)\">\n  `\n})\nexport class InfoComponent {\n  @Input() name;\n  @Output() nameChange = new EventEmitter();;\n}\n\n@Component({\n  selector: 'my-app',\n  template: `\n    <app-info [name]=\"name\" (nameChange)=\"name = $event\"></app-info>\n    Result: {{ name }}\n  `\n})\nexport class AppComponent  {\n  name = 'Mike'\n}\n```\n\n執行結果如下：\n\n![https://imgur.com/download/bYmH1X3](https://imgur.com/download/bYmH1X3)\n\n一個簡單的 two way binding 效果就完成了！\n\n不過這樣寫必須先 binding 一個屬性，在 binding 一個事件，還是稍微麻煩一點，實際上在 Angular 中，當有一個名為 `xxx` 的 `@Input` 時，只需要有一個對應的 `xxxChange` 的 `@Output`，即可使用 `[(xxx)]` 的方式，來完成 two way binding！所以上面程式在使用 `InfoComponent` 時，只需要改成：\n\n```html\n<app-info [(name)]=\"name\"></app-info>\n```\n\n就可以完成一樣的效果啦，是不是很簡單啊！\n\n同樣的原理我們再來看看 `[(ngModel)]` ，其實就是一個 `ngModel` 的 `@Input` 以及一個 `ngModelChange` 的 `@Output`，因此反過來我們如果想知道 binding 的值有變化時，只需要用 event binding 的方式，處理 `ngModelChange` 就可以了，如下：\n\n```typescript\n<input type=\"text\" [(ngModel)]=\"name\" (ngModelChange)=\"doSomething()\">\n```\n\n# 本日小結\n\n今天我們講了一個非常簡單的 two way binding 實現方式，透過這種方式，能夠讓把內容元件化時，更加的具有彈性，節省一些程式碼！\n\n當然這還是跟使用 `[(ngModel)]` 有所不同，畢竟他還是有表單控制項的效果，明天我們再來看看如何時做出能夠搭配 `[(ngModel)]` 使用的表單控制項元件吧！"
        },
        {
          "id": 2,
          "title": "exportAs - 取得 directive 實體的方法",
          "content": "Angular 提供了一種可以很擴充元件或HTML標籤屬性的方式，叫做 `directive`，透過這種方式我們可以很輕易地替現有的元件或 HTML 擴充它的顯示或行為，但單純擴充有時候是不夠的，如果我們希望能夠在程式中操作 directive 的話，今天學習的 `exportAs` 就是一個很好的使用時機。\n\n**類型**：技巧\n\n**難度**：3 顆星\n\n**實用度**：4 顆星\n\n# 先看看程式\n\n假設我們設計了一個簡單的 directive 如下：\n\n```typescript\n@Directive({\n  selector: '[appColorful]'\n})\nexport class ColorfulDirective {\n  @Input() appColorful;\n  @HostBinding('style.color') get color() {\n    console.log(this.appColorful);\n    return this.appColorful || 'red';\n  }\n}\n```\n\n這個 directive 很簡單，就是繫結宿主元素(host element)的 `color` 樣式而已，在使用時也很容易：\n\n```typescript\n<p appColorful=\"blue\">Hello World</p>\n```\n\n這本身是非常容易的一件事情，現在我們把 `directive` 稍微複雜化一點，變成下面程式：\n\n```typescript\n@Directive({\n  selector: '[appColorful]'\n})\nexport class ColorfulDirective {\n  @Input() appColorful;\n  @HostBinding('style.color') get color() {\n    console.log(this.appColorful);\n    return this.appColorful || 'red';\n  }\n\n  changeColor(color) {\n    this.appColorful = color;\n  }\n}\n```\n\n跟原來的程式相比，其實只是加了 `changeColor` 方法而已，我們希望可以在 TypeScript 裡面不透過屬性繫結的方式，來讓 `directive` 呼叫 `changeColor()` 方法改變顏色，接下來的問題是，如何取得這個 ｀directive｀ 實體呢？\n\n## 使用樣板參考變數試試看\n\n在設計 component 時，我們只需要掛上樣板參考變數，就能夠取得 component 的實體，例如：\n\n```htmll\n<!-- 此時的 colorful 就是 ColorfulComponent 本身 -->\n<app-colorful #colorful></app-colorful>\n```\n\n若是在樣板中的 component 在掛上 directive 時，很明顯的樣板參考變數也無法取得 directive 本身的實體，若是掛在單純的 HTML 標籤上呢？我們可以試試看會取得什麼東西？\n\n```typescript\n@Component({\n  selector: 'my-app',\n  template: `\n  <p appColorful=\"blue\" #color>Hello World</p>\n  <button (click)=\"change()\">Change Color</button>\n  `,\n  styleUrls: [ './app.component.css' ]\n})\nexport class AppComponent  {\n  @ViewChild('color') color;\n\n  change() {\n    console.log(this.color);\n  }\n}\n```\n\n在按下按鈕呼叫 `change()` 時，把這個變數印出來看看，如下：\n\n![https://wellwind.idv.tw/blog/2018/10/24/mastering-angular-09-get-directive-instance-with-exportAs/01.jpg](https://wellwind.idv.tw/blog/2018/10/24/mastering-angular-09-get-directive-instance-with-exportAs/01.jpg)\n\n可以看到我們單純的是取得 `ElementRef` 代表這個宿主元素的主體，而非 directive 本身。那麼到底要怎麼拿到 directive 實體呢？就是今天的重點 `exportAs` 啦！\n\n## 使用 exportAs\n\n在宣告 `@Directive()` 裝飾我們的 directive 時，裡面可以設定一個 `exportAs: string`，用來代表這個 directive 實體要以什麼名稱分享出去，所以我們的 `@Directive()` 可以調整成如下：\n\n```typescript\n@Directive({\n  selector: '[appColorful]',\n  // 加上 exportAs\n  exportAs: 'colorful'\n})\n```\n\n之後在樣板上就能夠改用 `#color=\"colorful\"` 的方式，正確的取得 directive 實體啦！取得這個實體後，就可以隨意呼叫裡面的方法：\n\n```typescript\n@Component({\n  selector: 'my-app',\n  template: `\n  <!-- 使用 #color=\"colorful\" 取得實體 -->\n  <p appColorful=\"blue\" #color=\"colorful\">Hello World</p>\n  <button (click)=\"change()\">Change Color</button>\n  `,\n  styleUrls: [ './app.component.css' ]\n})\nexport class AppComponent  {\n  // 確定取得的是 ColorDirective 的實體\n  @ViewChild('color') color: ColorfulDirective;\n\n  change() {\n    console.log(this.color);\n    this.color.changeColor('black');\n  }\n}\n```\n\n透過這種方式，我們在設計 directive 時，就可以透過 `exportAs` 來設定給外部程式使用的實體，就能夠在程式中針對 directive 進行更細緻的處理，整體設計時也會更加有彈性囉！\n\n> 在設計 `exportAs` 時，為了避免名稱衝突，通常都會直接設定成跟 `selector` 設定一樣的名稱。\n\n# 以表單元件舉例\n\n當我們使用 [Template driven form 進行表單驗證](https://angular.io/guide/form-validation#template-driven-validation)時，會出現像是 `#name=\"ngModel\"` 這樣的語法：\n\n```html\n<input id=\"name\" name=\"name\" [(ngModel)]=\"hero.name\" #name=\"ngModel\" >\n```\n\n其實就是 `ngModel` 這個 directive 也加上了 `exportAs: []`，[原始碼](https://github.com/angular/angular/blob/4c2ce4e8ba4c5ac5ce8754d67bc6603eaad4564a/packages/forms/src/directives/ng_model.ts#L106)看起來如下：\n\n```typescript\n@Directive({\n  selector: '[ngModel]:not([formControlName]):not([formControl])',\n  providers: [formControlBinding],\n  exportAs: 'ngModel'\n})\n```\n\n這樣是不是對 Template driven form 表單驗證常用技巧的原理更加熟悉一點啦！？\n\n# 本日小結\n\n今天我們介紹的 `exportAs` ，在一般應用程式中使用的頻率通常比較低，但使用 `exportAs` 也是有很多好處的，最明顯的是我們可以減少很多不必要的 `@Input` 等設計，直接取得 directive 實體並呼叫相關方法即可；同樣的我們也可以減少樣板上不必要的設定，把大部分的操作全部都移動到 TypeScript 之中，畢竟很多時候比起寫樣板上的語法，寫程式才是我們最擅長的啊！\n\n今天的範例程式碼參考：\n\nhttps://stackblitz.com/edit/itironman-2019-exportas\n\n# 相關資源\n\n- [Directive - exportAs](https://angular.io/api/core/Directive#exportAs)"
        },
        {
          "id": 3,
          "title": "使用 HTTP_INTERCEPTORS 攔截 Http Request",
          "content": "在開發 Angular 應用程式時，HTTP 請求絕對可以說是最常使用的功能之一，而在一般的應用情境上，我們很常會需要針對請求再做額外的包裝，或統一的管理，這時候我們就可以使用 `HTTP_INTERCEPTORS` 來協助我們攔截 HTTP 請求，並做額外的處理！\n\n**類型**：技巧\n\n**難度**：4 顆星\n\n**實用度**：5 顆星\n\n# 建立一個 HTTP_INTERCEPTORS 實體\n\n要建立 `HTTP_INTERCEPTORS` 很簡單，先建立一個 service，接著實作 `HttpInterceptor` 這個界面即可，如下：\n\n```typescript\n@Injectable()\nexport class AppHttpInterceptor implements HttpInterceptor {\n  constructor() { }\n  \n  public intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    console.log(req);\n    return next.handle(req);\n  }\n}\n```\n\n在上面程式中，我們建立了 service ，並實作 HttpInterceptor 介面的 intercept 方法，這個方法包含兩個參數：\n\n- `req: HttpRequest<any>`：代表目前送出的 HTTP 請求資訊\n- `next: HttpHandler`：代表一個可以用來處理 HTTP 請求的實體，HttpHandler 只有一個 `handle` 方法，裡面傳入的是另一個 `HttpRequest`\n\n在每次進入 intercept 時，必須回傳一個新的 `HttpRequest` 請求，由於我們還沒有要處理任何事情，所以使用 `next.handle(req)`，把目前的請求當作當作新的來處理。\n\n建立好 service 之後，我們要讓 Angular 程式知道要使用這個 `HTTP_INTERCEPTORS`，實際上它是一個可以被注入的 token，因此可以在要使用的 `@NgModule` 加入此設定：\n\n```typescript\n@NgModule({\n  ...,\n  providers: [{\n    provide: HTTP_INTERCEPTORS,\n    useClass: AppHttpInterceptor,\n    multi: true,\n  }],\n})\nexport class AppModule {}\n```\n\n在這裡加入 `multi: true` 的用意是，讓 Angular 知道 `HTTP_INTERCEPTORS` 是可能有多個程式在處理的。\n\n接著只要在程式中任何地方注入 `HttpClient` 並送出 HTTP 請求，就可以看到相關資訊被攔截，且被 `console.log` 記錄下來啦！\n\n接著我們來看看實務上兩種常見使用 `HTTP_INTERCEPTORS` 的方法，剛好也代表了請求前和請求後處理的範例。\n\n# 在請求前加上認證 token\n\n在 SPA 架構下，想要完成認證功能，通常是把帳號密碼送到後端驗證，並請求一個 token 並暫時存下來，之後每次的 HTTP 請求再將此 token 放在 request header 送給後端 API，API 端則需要驗證此 token 是否合法，若合法才允許存取相關資源。\n\n因此我們可以在每次攔截到請求時，替 request 加上要驗證的 token，在傳送出去，如下：\n\n```typescript\n@Injectable()\nexport class TokenAuthHttpInterceptor implements HttpInterceptor {\n  constructor() { }\n  public intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    // token 可以來自任何地方\n    const newRequest = req.clone({ setHeaders: {Authorization: 'Bearer 123456'}});\n    return next.handle(newRequest);\n  }\n}\n```\n\n在上述程式中，我們使用 `req.clone()` 的方式，設定 `Authorization` 的內容。\n\n我們其實可以使用 `req.headers` 來取得目前要送出的 headers 資訊，那麼為什麼要用 `req.clone()` 來建立新的 request 呢，因為 `HttpRequest` 內的屬性大多是唯獨的，因此 `HttpRequest` 額外提供了 `clone` 方法，來建立新的請求。\n\n這時候若打開 F12，就可以看到每次發出 HTTP 請求時都會帶著我們設定好的 header 啦！\n\n# 全域的處理 HTTP 回應錯誤\n\n一般來說，我們會預期後端的 API 都是正常的，且在上線環境我們的請求也是都正確並測試過的，因此當發生錯誤時，都應該會是未預期的錯誤，例如 API 伺服器掛掉，甚至是改版等等。我們可以在每次使用 `HttpClient` 時都去處理這些錯誤，也可以在攔截時就預先進行處理，如下：\n\n```typescript\n@Injectable()\nexport class BackendApiHttpInterceptor implements HttpInterceptor {\n  constructor(private dialog: MatDialog, private systemService: SystemService) {}\n\n  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    return next.handle(req).pipe(\n      catchError((error: HttpErrorResponse) => {\n        console.log(error);\n        throwError(error);\n        return of(null);\n      })\n    );\n  }\n}\n```\n\n由於 `next.handle(req)` 回傳的是一個 observable，因此我們可以在這個時候針對取得的資料在做一些處理，例如上面程式我們使用了 `catchError` 這個 RxJS 的 operator，在錯誤發生的時候記錄下來，並把錯誤再次拋出，透過這樣的方式，我們就能夠在 HTTP 發生錯誤時第一時間得知並處理囉。\n\n# 本日小結\n\nHTTP 請求幾乎是所有前端程式都會用到的功能，因此能夠全域的攔截並處理請求及回應資訊是非常重要的一件事請，才能大量減少重複的程式碼，寫出來的程式也會更加簡單！\n\n# 相關資源\n\n- [Intercepting requests and responses](https://angular.io/guide/http#intercepting-requests-and-responses)\n  - 官方文件提供了不少應用情境，值得參考一下\n- [HTTP_INTERCEPTORS](https://angular.io/api/common/http/HTTP_INTERCEPTORS)\n- [HttpHandler](https://angular.io/api/common/http/HttpHandler)\n- [HttpRequest](https://angular.io/api/common/http/HttpRequest)"
        },
        {
          "id": 4,
          "title": "認識 AsyncPipe (1) - 基本使用技巧",
          "content": "在撰寫前端程式時，我們很難避免會遇到非同步的程式處理，在大量使用 RxJS 的 Angular 中更是如此，而今天我們要介紹的 AsyncPipe 在樣板上要處理非同步可以說是非常方便的工具！\n\n**類型**：觀念\n\n**難度**：4 顆星\n\n**實用度**：5 顆星\n\n# 基本用法\n\n先來看看一個常見的非同步狀況 - Http Request！\n\n```typescript\n@Component({\n  selector: 'myㄦapp',\n  template: `\n  <ul>\n    <li *ngFor=\"let todo of todos\">{{ todo.title }}</li>\n  </ul>\n  `\n})\nexport class AppComponent {\n  todos: any[];\n\n  constructor(private httpClient: HttpClient) { }\n\n  ngOnInit() {\n    this.httpClient.get('https://jsonplaceholder.typicode.com/todos/')\n      .subscribe((data: any[]) => {\n        this.todos = data;\n      });\n  }\n}\n```\n\n在上面程式中，我們使用 `HttpClient` 去呼叫一個 API ，由於 HttpClient 的 `get` 方法會回傳一個 observable，因此我們可以透過 `subscribe` 方法，去訂閱結果，並放在類別的一個參數內。\n\n由於 Http Request 是非同步的程式， observable 也是，因此我們可以先把這個非同步的物件保留起來，而不是立刻呼叫 `subscribe` 方法：\n\n```typescript\nimport { Observable } from 'rxjs';\n\nexport class AppComponent {\n  todos$: Observable<any[]>;\n\n  constructor(private httpClient: HttpClient) { }\n\n  ngOnInit() {\n    this.todos$ = this.httpClient.get<any[]>('https://jsonplaceholder.typicode.com/todos/');\n  }\n}\n```\n\n在這裡我們改用宣告一個型別為 `Observable<any[]>` 的變數 `todos$`，並直接把 HttpClient 取得的物件指派給這個變數，而不再做訂閱的行為，因此目前不會有任何的 Http Request 發生，程式看起來也比較清爽。\n\n> 在開發習慣中，我們會在變數後面加上一個 `$` 符號，代表他是一個 observable。\n\n那麼到底什麼時候才會執行訂閱動作呢？我們可以在樣板上針對 `todos$` 變數後面加上一個 `async` 的 pipe，讓這個 AsyncPipe 來幫助我們訂閱！\n\n```typescript\n<li *ngFor=\"let todo of todos$ | async\">{{ todo.title }}</li>\n```\n\n如此一來就可以在樣板上由 AsyncPipe 來幫我們訂閱啦！接下來我們看看還有沒有什麼其他的技巧吧！\n\n> AsyncPipe 也可以幫助我們自動處理 Promise，不過在 Angular 中還是使用 RxJS 居多。\n\n# 類延遲載入\n\n由於我們現在把訂閱的工作交給樣板上的程式了，因此資料不會在元件開始的時候就載入，而是在樣板中有需要顯示的時候才載入，因此我們可以做出一個類似延遲載入的效果：\n\n```typescript\n@Component({\n  selector: 'my-app',\n  template: `\n  <button (click)=\"loadTodos()\">Load Todos</button>\n  <ul *ngIf=\"load\">\n    <li *ngFor=\"let todo of todos$ | async\">{{ todo.title }}</li>\n  </ul>\n  `\n})\nexport class AppComponent {\n  load: boolean;\n  todos$: Observable<any[]>;\n\n  constructor(private httpClient: HttpClient) { }\n\n  ngOnInit() {\n    this.todos$ = this.httpClient.get<any[]>('https://jsonplaceholder.typicode.com/todos/');\n  }\n\n  loadTodos() {\n    this.load = !this.load;\n  }\n}\n```\n\n在這段程式中，畫面一開始不會載入資料，因為 `todos$ | async` 的部分並沒有被載入，當按下按鈕把 `this.load` 設為 `true` 時，才會進行載入的動作，透過這種方式，我們就可以在真正需要資料時才進行載入的動作，避免不必要的 API 呼叫啦！\n\n# 使用 shareReplay 避免重複載入\n\n在上一段程式中，我們可以透過設定 `this.load` 來決定資料是否要被載入，而當每次 `this.load` 被設定為 `true` 時，都會再次呼叫 API，若希望只有第一次要顯示時呼叫就好，可以使用 RxJS 的 `shareReplay` operator，這個 operator 會保留最近 N 次(看設定) 的內容，當 observable 被訂閱時，預設會先「重播」最新 N 次的紀錄！\n\n因此上述呼叫的程式就可以改為：\n\n```typescript\n// import { shareReplay } from 'rxjs/operators'; \nngOnInit() {\n  this.todos$ = this.httpClient\n    .get<any[]>('https://jsonplaceholder.typicode.com/todos/')\n    // 重播最近一次的資料\n    .pipe(shareReplay(1));\n}\n```\n\n這時候可以打開 F12 的 network 頁籤看看，再切換 `this.load` 時，就不會重複一直載入囉！\n\n# 搭配 ngIf 使用\n\n另外一種常見的情境是搭配 `*ngIf` 使用，也就是在真正呼叫 Http Request 時，我們的 observable 是沒資料的，因此 `*ngIf` 的宿主標籤不會被顯示，搭配 AsyncPipe 訂閱後，真正得到資料時才顯示內容，如下：\n\n```html\n<ng-container *ngIf=\"todos$ | async; else loading\">>\n  <ul>\n    <li *ngFor=\"let todo of todos$ | async\">{{ todo.title }}</li>\n  </ul>\n</ng-container>\n<ng-template #loading>Loading...</ng-template>\n```\n\n這段程式可以運作得非常好，在 Http Request 還沒完成的期間顯示 `Loading...` 內容，直到有資料後才顯示內容，但需要使用兩次 AsyncPipe，雖然我們已經知道可以搭配 `shareReplay` 來避免重複呼叫，但是套用多個 AsyncPipe 還是感覺醜醜的，這時候可以加上 `as` ，把訂閱的結果存到另一個區域變數中，如下：\n\n```html\n<ng-container *ngIf=\"todos$ | async as todos; else loading\">\n  <ul>\n    <!-- 在內部就不需要使用 todos$ | async，而是使用 as 後面的 todos 區域變數 -->\n    <li *ngFor=\"let todo of todos\">{{ todo.title }}</li>\n  </ul>\n</ng-container>\n```\n\n這樣看起來就清爽多啦！\n\n今天就先介紹幾種常用的情境，明天再來看看更複雜的應用情境吧！\n\n# 相關資源\n\n- [AsyncPipe](https://angular.io/api/common/AsyncPipe)\n- [NgIf](https://angular.io/api/common/NgIf)\n- [shareReplay](https://rxjs-dev.firebaseapp.com/api/operators/shareReplay)"
        },
        {
          "id": 5,
          "title": "認識 AsyncPipe (2) - 進階技巧",
          "content": "今天我們來認識一下兩個重要的 AsyncPipe 特性，可以幫助我們在使用 AsyncPipe 時更有信心，打造出更高效能的程式！\n\n**類型**：觀念/技巧\n\n**難度**：5 顆星\n\n**實用度**：4 顆星\n\n# 特性 1：自動退訂\n\n先來看看這段簡單的程式碼：\n\n```typescript\nimport { Component, OnInit, OnDestroy} from '@angular/core';\nimport { interval } from 'rxjs';\n\n@Component({\n  selector: 'app-counter',\n  template: `{{ value }}`\n})\nexport class CounterComponent implements OnInit, OnDestroy {\n  value = 0\n\n  ngOnInit() {\n    interval(1000).subscribe((counter) => {\n      console.log(counter);\n      this.value = counter;\n    })\n  }\n\n  ngOnDestroy() {\n    console.log('destroy');\n  }\n}\n\n\n@Component({\n  selector: 'my-app',\n  template: `\n    <app-counter *ngIf=\"display\"></app-counter>\n    <button (click)=\"display = !display\">Toggle</button>\n  `,\n})\nexport class AppComponent  {\n  display = true;\n}\n```\n\n在上面的程式碼中，我們設計了 `CounterComponent` 並使用 RxJS 的 `interval()` 在訂閱後每秒變更一次資料，另外在畫面上設計一個按鈕來決定是否需要銷毀這個元件，當 `display` 為 `false` 時，`<app-counter>` 元件將會被銷毀，而當 `display` 為 `true` 時， `<app-counter>` 元件將重新產生。\n\n看起來一切沒什麼問題，但是當我們打開 F12 時會發現，雖然元件被摧毀了，但 `interval()` 的行為並沒有停止！這將會造成每次產生元件時，就會產生一段新的 `interval()` ，當次數多了後將會佔據大量的記憶體，進而發生 memory leak 的問題；要避免這問題，最直覺的方式是當元件要被璀毀時，於 `ngOnDestroy` 方法內使用 `unsubscribe` 取消訂閱：\n\n```typescript\nexport class CounterComponent implements OnInit, OnDestroy {\n  value = 0\n  subscription: Subscription;\n\n  ngOnInit() {\n    this.subscription = interval(1000).subscribe((counter) => {\n      console.log(counter);\n      this.value = counter;\n    })\n  }\n\n  ngOnDestroy() {\n    console.log('destroy');\n    this.subscription.unsubscribe();\n  }\n}\n```\n\n雖然取消訂閱人人有責，但是當程式中的 observable 越來越多時，總是會有不小心忘記訂閱的時候，這時 AsyncPipe 就能派上大作用啦！\n\n## 使用 AsyncPipe 的自動退訂機制\n\n從 [AsyncPipe 的程式碼](https://github.com/angular/angular/blob/7.0.x/packages/common/src/pipes/async_pipe.ts#L25)可以看到，當 AsyncPipe 處理 observable 時，會在 [ngOnDestoy 時](https://github.com/angular/angular/blob/7.0.x/packages/common/src/pipes/async_pipe.ts#L81-L85)自動將 observable 退訂！因此上面的程式我們可以簡單改寫為：\n\n```typescript\n@Component({\n  selector: 'app-counter',\n  template: `{{ value$ | async }}`\n})\nexport class CounterComponent implements OnInit {\n  value$: Observable<number>;\n\n  ngOnInit() {\n    this.value$ = interval(1000).pipe(\n      tap(counter => console.log(counter))\n    );\n  }\n}\n```\n\n由於 AsyncPipe 會自動退訂的關係，我們不再需要手動執行退訂的程式，整個程式看起來是不是清爽多啦！\n\n# 特性 2：自動要求變更偵測\n\n在 [AsyncPipe 程式碼的另一角落](https://github.com/angular/angular/blob/7.0.x/packages/common/src/pipes/async_pipe.ts#L143)，我們可以發現在資料變更時(不管是 Promise 還是 RxJS)，會自動使用 `ChangeDetectorRef` 的 `markForCheck()` 方法，自動要求變更偵測發生；會有這樣的程式需求也不難理解，當我們給予一個 observable 實體時，不管內部的值再怎麼變化，observable 的實體參考位置也不會變化，因此當元件的變更偵測策略為 `OnPush` 時，使用 AsyncPipe 就會發生沒有進行變更偵測的問題！所以 AsyncPipe 在訂閱(或呼叫 `then()`)的同時，也會要求變更偵測需要處理！\n\n## 搭配 OnPush 策略\n\n透過上述提到的特性，如果元件中只剩下 observable + AsyncPipe 時，我們就可以光明正大地把元件的 `OnPush` 策略打開，並且完全不用手動去呼叫 `markForCheck` 方法，AsyncPipe 會在需要變更偵測時主動幫我們處理！\n\n```typescript\n@Component({\n  selector: 'app-counter',\n  template: `{{ (data$ | async)?.value }}`,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class CounterComponent implements OnInit {\n  @Input() data$: Observable<any>;\n  ngOnInit() { }\n}\n```\n\n從此以後每個單純用來顯示資料的元件，再打開 `OnPush` 之後，既能夠維持元件一定程度的高效能，又不怕忘記呼叫 `markForCheck` 啦！\n\n善用 RxJS 與 AsyncPipe，要打造出既好維護，相對效能又高的元件一點都不困難啊！！\n\n今天的程式碼參考連結：\n\nhttps://stackblitz.com/edit/ironman2019-asyncpipe-onpush?file=src/app/app.component.ts"
        },
        {
          "id": 6,
          "title": "認識 InjectionToken",
          "content": "在 Angular 中不是只有 service 可以當 token 被注入，我們也可以單純的注入某個物件，這個物件通常是一個全域的系統設定，或是單純的一個函數(function)，這時候就會遇到一些問題，我們今天就來看看問題是什麼，以及如何解決！\n\n<!-- more -->\n\n**類型**：觀念\n\n**難度**：4 顆星\n\n**實用度**：5 顆星\n\n# 一般情境\n\n可以用我們之前學過的 `useValue`，類似以下程式：\n\n```typescript\nexport class Config {\n  LogLevel: string\n}\n\n@NgModule({\n  providers: [\n    {\n      provide: Config,\n      useValue: { LogLevel: 'Error' }\n    }\n  ]\n})\nexport class AppModule { }\n```\n\n這完全不是問題，但如果不想宣告成 `class` (畢竟會產生實際程式碼) 或是設定的不是物件，而是數值或字串呢？就會出問題了：\n\n```typescript\nexport interface Config {\n  LogLevel: string\n}\n\n@NgModule({\n  providers: [\n    {\n      // 錯誤，因為 interface 不會產生實體\n      provide: Config,\n      useValue: { LogLevel: 'Error' }\n    }\n  ]\n})\nexport class AppModule { }\n```\n\n這時候可以使用 Angular 提供的 `InjectionToken` 來強制幫我們產生一個 token\n\n# 使用 InjectionToken\n\n```typescript\nimport { InjectionToken } from '@angular/core';\n\nexport interface Config {\n  LogLevel: string\n}\n\n// 替 interface 產生一個 token\n// 參數的字串只是一個描述\nexport const CONFIG_TOKEN = new InjectionToken<Config>('config token');\n// 基礎型別也不是問題\nexport const NAME_TOKEN = new InjectionToken<string>('name token');\n\n@NgModule({\n  providers: [\n    {\n      provide: CONFIG_TOKEN,\n      useValue: { LogLevel: 'Error' }\n    },\n    {\n      provide: NAME_TOKEN,\n      useValue: 'Mike'\n    }\n  ]\n})\nexport class AppModule { }\n```\n\n至於要如何取得 token 實體呢？可以使用 `@Inject()` 裝飾器，來告知要使用哪個 token 注入：\n\n```typescript\nconstructor(@Inject(CONFIG_TOKEN) private config: Config) {\n  console.log(config);\n}\n```\n\n# Tree-shakable InjectionToken\n\n`InjectionToken` 是非常特別的存在，通常都是提供給使用某個套件的人一些從外部設定的資訊，因此很多時候我們並不一定會去設定這個 token，但偏偏 `InjectionToken` 會真的產生實體，導致在進行 tree shaking 時無法過濾掉，跟傳統建立 service 的問題很類似，因此在 Angular 6 之後，也透過 `providedIn: 'root'` 的方法，來進行過濾：\n\n```typescript\nconst CONFIG_TOKEN = new InjectionToken<Config>('config token',\n  {\n    providedIn: 'root',\n    factory: () => ({\n      LogLevel: 'Error'\n    })\n  }\n);\n```\n\n透過這種方式，當程式中有使用到 `CONFIG_TOKEN` 時，就會使用 `factory: () => {}` 產生的內容；若需要調整 token 的實體，在 `@NgModule` 的 `providers: []` 設定即可；而當完全沒有使用 `CONFIG_TOKEN` 時，這個被產生的內容也可以被過濾掉啦！\n\n# 相關資源\n\n- [InjectinToken](https://angular.io/api/core/InjectionToken)\n- [Inject](https://angular.io/api/core/inject)"
        }
      ]
    },
    {
      "name": "Work",
      "items": [
        { "id": 7, "title": "Test 2 - 1", "content": "2 - 1\n---\n# Heading 1\n~~test~~\n\n* item 1\n* item 2\n\n ## Heading 2" },
        {
          "id": 8,
          "title": "Test 2 - 2",
          "content": "2 - 2\n---\n# Heading 1\n~~test~~\n\n* item 1\n* item 2\n\n ## Heading 2"
        },
        {
          "id": 9,
          "title": "Test 2 - 3",
          "content": "2 - 3\n---\n# Heading 1\n~~test~~\n\n* item 1\n* item 2\n\n ## Heading 2"
        }
      ]
    },
    {
      "name": "Project",
      "items": [
        {
          "id": 10,
          "title": "Test 3 - 1",
          "content": "3 - 1\n---\n# Heading 1\n~~test~~\n\n* item 1\n* item 2\n\n ## Heading 2"
        },
        {
          "id": 11,
          "title": "Test 3 - 2",
          "content": "3 - 2\n---\n# Heading 1\n~~test~~\n\n* item 1\n* item 2\n\n ## Heading 2"
        },
        { "id": 12, "title": "Test 3 - 3", "content": "3 - 3\n---\n# Heading 1\n~~test~~\n\n* item 1\n* item 2\n\n ## Heading 2" }
      ]
    }
  ]
}
